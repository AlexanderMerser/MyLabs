/*
 * Напишите функцию setbits(x,p,n,y) так, чтобы она возвращала аргумент x,
 * в котором n битов, начиная с позиции p, равны n крайним правым битам аргумента y,
 * а остальные биты не тронуты
*/
#include <stdio.h>
unsigned setbits(unsigned x, int p, int n, unsigned y) {
	//printf ("%u\n",~(~0 << p) & x);
	//printf ("%u\n", ~(~0 << n) & y);
	//printf ("%u\n",(x >> p & (~0 << n) ));
	//printf ("%u",(x >> p & (~0 << n) | ~(~0 << n) & y) << p | ~(~0 << p) & x);
	return (x >> p & (~0 << n) | ~(~0 << n) & y) << p | ~(~0 << p) & x;

}
int main (int argv, char ** argc){
	printf("%u\n", setbits(127,1,5,0));
	// Проверка: На вход подается 127 (0111 1111) Замена происходит с 1 бита и заменяет 5
	// первыми битами из последовательности 0 (000[0 0000]) получаем 0100 0001 (65
	// что и требовалось доказать
	return 0;
}
